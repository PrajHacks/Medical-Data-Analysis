import streamlit as st
import pandas as pd
import statsmodels.formula.api as smf
import matplotlib.pyplot as plt
import seaborn as sns
import os # Import os module to get file extension
from collections import Counter # Import Counter for handling duplicate column names

# Set page configuration
st.set_page_config(layout="wide", page_title="Hemoglobin Regression Analysis")

st.title("🍵 Hemoglobin Level Regression Analysis")
st.markdown("""
This application performs a multiple linear regression analysis to understand the relationship
between 'tea in grams', 'therapy duration', and 'change in hemoglobin levels'.
""")

st.header("Upload Your Data")
# Updated file uploader to accept CSV, XLSX, and XLS files
uploaded_file = st.file_uploader("Choose a CSV or Excel file (XLSX, XLS)", type=["csv", "xlsx", "xls"])

if uploaded_file is not None:
    try:
        # Determine file type and read accordingly
        file_extension = os.path.splitext(uploaded_file.name)[1].lower()

        # Read the file, with header=[0, 1] to capture the first two rows as a multi-index header
        if file_extension == ".csv":
            df = pd.read_csv(uploaded_file, header=[0, 1])
        elif file_extension in [".xlsx", ".xls"]:
            df = pd.read_excel(uploaded_file, header=[0, 1])
        else:
            st.error("Unsupported file type. Please upload a CSV, XLSX, or XLS file.")
            st.stop() # Stop execution if file type is not supported

        # --- Improved logic to flatten multi-index columns and ensure uniqueness ---
        new_columns = []
        for col_idx, col_tuple in enumerate(df.columns):
            if isinstance(col_tuple, tuple):
                # Clean up each part of the tuple
                part1 = str(col_tuple[0]).strip() if col_tuple[0] is not None else ''
                part2 = str(col_tuple[1]).strip() if col_tuple[1] is not None else ''

                # Handle 'Unnamed' columns generated by pandas for empty cells in header rows
                if part1.startswith('Unnamed:'):
                    part1 = ''
                if part2.startswith('Unnamed:'):
                    part2 = ''

                # Combine parts intelligently
                if part1 and part2:
                    new_col_name = f"{part1}_{part2}"
                elif part1:
                    new_col_name = part1
                elif part2:
                    new_col_name = part2
                else:
                    # Fallback for completely empty headers, use a generic unique name
                    new_col_name = f"Column_{col_idx}"
                new_columns.append(new_col_name)
            else:
                # For single-level headers that might not be tuples
                new_columns.append(str(col_tuple).strip())

        # Ensure uniqueness of column names after initial flattening
        col_counts = Counter(new_columns)
        final_unique_columns = []
        for col_name in new_columns:
            if col_counts[col_name] > 1:
                # Append a number to make it unique if it's a duplicate
                count = 1
                original_col_name = col_name
                # Check against already added unique names and remaining original names
                while f"{original_col_name}_{count}" in final_unique_columns or f"{original_col_name}_{count}" in new_columns[new_columns.index(col_name) + 1:]:
                    count += 1
                final_unique_columns.append(f"{original_col_name}_{count}")
            else:
                final_unique_columns.append(col_name)

        df.columns = final_unique_columns
        st.success("File uploaded successfully and headers processed!")
        st.subheader("Raw Data Preview (after header processing)")
        st.write(df.head())

        # Standardize column names for easier access (remove leading/trailing spaces)
        df.columns = df.columns.str.strip()

        # --- IMPORTANT: Adjusting column names based on user's specific file structure ---

        # Define potential column names for independent and dependent variables
        # Prioritize names explicitly mentioned by the user for 'calculations' section
        possible_independent_var1_names = ['calculations_tea/coffee in grams', 'tea']
        possible_independent_var2_names = ['calculations_therapy length']
        possible_dependent_var_names = ['calculations_change in hb']

        independent_var1 = None
        independent_var2 = None
        dependent_var = None

        # Identify independent_var1 (tea in grams)
        for name in possible_independent_var1_names:
            if name in df.columns:
                independent_var1 = name
                break
        if independent_var1 is None:
            st.error(f"Error: Could not find 'tea in grams' column. Looked for: {', '.join(possible_independent_var1_names)}. Please ensure it's present or adjust the code.")
            st.stop()

        # Identify independent_var2 (therapy duration)
        for name in possible_independent_var2_names:
            if name in df.columns:
                independent_var2 = name
                break

        # Fallback for therapy duration: calculate from Hemoglobin Start/End dates
        if independent_var2 is None:
            st.info("Attempting to calculate 'therapy duration' from 'Hemoglobin_Start' and 'Hemoglobin_End' dates.")
            start_date_col = None
            end_date_col = None
            for col in df.columns:
                if 'Hemoglobin_Start' in col:
                    start_date_col = col
                if 'Hemoglobin_End' in col:
                    end_date_col = col

            if start_date_col and end_date_col:
                df[start_date_col] = pd.to_datetime(df[start_date_col], errors='coerce')
                df[end_date_col] = pd.to_datetime(df[end_date_col], errors='coerce')
                df['therapy_duration_days'] = (df[end_date_col] - df[start_date_col]).dt.days
                independent_var2 = 'therapy_duration_days'
            else:
                st.error("Error: Could not find 'calculations_therapy length' or 'Hemoglobin_Start' and/or 'Hemoglobin_End' date columns to calculate 'therapy duration'. Please ensure your file has these columns or adjust the code.")
                st.stop()

        # Identify dependent_var (change in hemoglobin)
        for name in possible_dependent_var_names:
            if name in df.columns:
                dependent_var = name
                break

        # Fallback for change in hemoglobin: calculate from Hemoglobin_End and Baseline
        if dependent_var is None:
            st.info("Attempting to calculate 'change in hemoglobin' from 'Hemoglobin_End' and 'Baseline'.")
            final_hemoglobin_col = None
            if 'Hemoglobin' in df.columns: # Check for top-level Hemoglobin column
                final_hemoglobin_col = 'Hemoglobin'
            elif 'Hemoglobin_End' in df.columns: # Check for combined Hemoglobin_End
                final_hemoglobin_col = 'Hemoglobin_End'

            if final_hemoglobin_col and 'Baseline' in df.columns:
                df['Baseline'] = pd.to_numeric(df['Baseline'], errors='coerce')
                df[final_hemoglobin_col] = pd.to_numeric(df[final_hemoglobin_col], errors='coerce')
                df['change_in_hemoglobin_calculated'] = df[final_hemoglobin_col] - df['Baseline']
                dependent_var = 'change_in_hemoglobin_calculated'
            else:
                st.error("Error: Could not find 'calculations_change in hb' or sufficient columns ('Hemoglobin'/'Hemoglobin_End' and 'Baseline') to calculate the change in hemoglobin. Please verify your file's column structure.")
                st.stop()


        # Final check if all required columns are identified and exist
        required_columns = [independent_var1, independent_var2, dependent_var]
        missing_columns_after_identification = [col for col in required_columns if col not in df.columns]

        if missing_columns_after_identification:
            st.error(f"Critical Error: After all attempts, the following required columns are still missing: {', '.join(missing_columns_after_identification)}. Please check your data and column names.")
            st.stop()
        else:
            st.success(f"Identified independent variables: '{independent_var1}', '{independent_var2}'")
            st.success(f"Identified dependent variable: '{dependent_var}'")


            st.subheader("Data Preprocessing")
            st.info("Cleaning data by converting relevant columns to numeric and dropping rows with missing values.")

            # Convert relevant columns to numeric, coercing errors to NaN
            df[independent_var1] = pd.to_numeric(df[independent_var1], errors='coerce')
            df[independent_var2] = pd.to_numeric(df[independent_var2], errors='coerce')
            df[dependent_var] = pd.to_numeric(df[dependent_var], errors='coerce')

            # Drop rows where any of the key columns have NaN values
            df_cleaned = df.dropna(subset=[independent_var1, independent_var2, dependent_var])

            if df_cleaned.empty:
                st.warning("After cleaning, no valid data rows remain for analysis. Please check your data for non-numeric values or missing information in the specified columns.")
            else:
                st.write(f"Original rows: {len(df)}, Rows after cleaning: {len(df_cleaned)}")
                st.subheader("Cleaned Data Preview")
                st.write(df_cleaned.head())

                st.subheader("Regression Analysis")

                # Perform Multiple Linear Regression using statsmodels formula API
                # Formula: dependent_var ~ independent_var1 + independent_var2
                # Use Q() for all variable names to handle spaces/special characters
                formula = f"Q('{dependent_var}') ~ Q('{independent_var1}') + Q('{independent_var2}')"

                try:
                    model = smf.ols(formula=formula, data=df_cleaned).fit()
                    st.success("Regression model fitted successfully!")

                    st.subheader("Regression Results Summary")
                    st.write(model.summary())

                    st.subheader("Key Insights from the Analysis")
                    st.markdown("""
                    The regression analysis helps us understand how 'tea in grams' and 'therapy duration'
                    individually and collectively influence the 'change in hemoglobin levels'.
                    """)

                    st.markdown("---")
                    st.markdown("#### 1. R-squared Value")
                    st.write(f"**R-squared:** `{model.rsquared:.4f}`")
                    st.markdown("""
                    The R-squared value indicates the proportion of the variance in the dependent variable
                    (change in hemoglobin) that can be predicted from the independent variables
                    (tea in grams and therapy duration). A higher R-squared suggests a better fit of the model to the data.
                    """)

                    st.markdown("---")
                    st.markdown("#### 2. Coefficients and P-values")
                    st.markdown("""
                    The coefficients tell us the average change in the dependent variable for a one-unit increase
                    in the independent variable, holding other independent variables constant.
                    The P-value indicates the statistical significance of each independent variable.
                    A P-value less than 0.05 (or your chosen significance level) typically suggests that the variable
                    is statistically significant in predicting the dependent variable.
                    """)

                    st.write("##### Coefficients:")
                    st.write(model.params.round(4))
                    st.write("##### P-values:")
                    st.write(model.pvalues.round(4))

                    # Interpret coefficients based on p-values
                    st.markdown("---")
                    st.markdown("#### 3. Interpretation of Variables:")

                    # Intercept
                    st.write(f"- **Intercept:** `{model.params['Intercept']:.4f}`")
                    st.markdown("""
                    This is the predicted 'change in hemoglobin' when both 'tea in grams' and 'therapy duration' are zero.
                    In many real-world scenarios, an intercept might not have a direct practical interpretation if zero values for independent variables are not meaningful.
                    """)

                    # Tea in grams
                    tea_coeff = model.params[f"Q('{independent_var1}')"]
                    tea_pvalue = model.pvalues[f"Q('{independent_var1}')"]
                    st.write(f"- **Tea in Grams (Coefficient: `{tea_coeff:.4f}`, P-value: `{tea_pvalue:.4f}`):**")
                    if tea_pvalue < 0.05:
                        st.markdown(f"""
                        For every one-unit increase in 'tea in grams', the 'change in hemoglobin' is predicted to change by `{tea_coeff:.4f}` units,
                        assuming 'therapy duration' remains constant. This variable is **statistically significant** (P-value < 0.05).
                        """)
                    else:
                        st.markdown(f"""
                        For every one-unit increase in 'tea in grams', the 'change in hemoglobin' is predicted to change by `{tea_coeff:.4f}` units,
                        assuming 'therapy duration' remains constant. This variable is **not statistically significant** (P-value >= 0.05),
                        meaning we don't have enough evidence to conclude it has a significant linear relationship with hemoglobin change in this model.
                        """)

                    # Therapy duration
                    therapy_coeff = model.params[f"Q('{independent_var2}')"]
                    therapy_pvalue = model.pvalues[f"Q('{independent_var2}')"]
                    st.write(f"- **Therapy Duration (Coefficient: `{therapy_coeff:.4f}`, P-value: `{therapy_pvalue:.4f}`):**")
                    if therapy_pvalue < 0.05:
                        st.markdown(f"""
                        For every one-unit increase in 'therapy duration', the 'change in hemoglobin' is predicted to change by `{therapy_coeff:.4f}` units,
                        assuming 'tea in grams' remains constant. This variable is **statistically significant** (P-value < 0.05).
                        """)
                    else:
                        st.markdown(f"""
                        For every one-unit increase in 'therapy duration', the 'change in hemoglobin' is predicted to change by `{therapy_coeff:.4f}` units,
                        assuming 'tea in grams' remains constant. This variable is **not statistically significant** (P-value >= 0.05),
                        meaning we don't have enough evidence to conclude it has a significant linear relationship with hemoglobin change in this model.
                        """)

                    st.markdown("---")
                    st.subheader("Visualizations")

                    # Scatter plot: Tea in grams vs. Change in Hemoglobin
                    fig1, ax1 = plt.subplots(figsize=(10, 6))
                    sns.scatterplot(x=independent_var1, y=dependent_var, data=df_cleaned, ax=ax1)
                    ax1.set_title(f'Scatter Plot: {independent_var1} vs. {dependent_var}')
                    ax1.set_xlabel(independent_var1)
                    ax1.set_ylabel(dependent_var)
                    st.pyplot(fig1)

                    # Scatter plot: Therapy Duration vs. Change in Hemoglobin
                    fig2, ax2 = plt.subplots(figsize=(10, 6))
                    sns.scatterplot(x=independent_var2, y=dependent_var, data=df_cleaned, ax=ax2)
                    ax2.set_title(f'Scatter Plot: {independent_var2} vs. {dependent_var}')
                    ax2.set_xlabel(independent_var2)
                    ax2.set_ylabel(dependent_var)
                    st.pyplot(fig2)

                    # Residuals plot
                    # Residuals are the differences between observed and predicted values
                    df_cleaned['residuals'] = model.resid
                    fig3, ax3 = plt.subplots(figsize=(10, 6))
                    sns.scatterplot(x=model.fittedvalues, y=df_cleaned['residuals'], ax=ax3)
                    ax3.axhline(y=0, color='r', linestyle='--')
                    ax3.set_title('Residuals vs. Fitted Values Plot')
                    ax3.set_xlabel('Fitted Values (Predicted Hemoglobin Change)')
                    ax3.set_ylabel('Residuals')
                    st.pyplot(fig3)
                    st.markdown("""
                    The residuals plot helps to check the assumptions of linear regression.
                    Ideally, residuals should be randomly scattered around zero, with no clear pattern.
                    Patterns might indicate that the linear model is not the best fit or that other variables are missing.
                    """)

                    st.markdown("---")
                    st.subheader("Further Considerations")
                    st.markdown("""
                    * **Causation vs. Correlation:** Remember that regression analysis shows correlation, not necessarily causation.
                        Other unmeasured factors might influence hemoglobin levels.
                    * **Data Quality:** The quality of the insights heavily depends on the quality and representativeness of your input data.
                    * **Model Assumptions:** Linear regression relies on several assumptions (linearity, independence of errors, homoscedasticity, normality of residuals).
                        Violations of these assumptions can affect the reliability of the results.
                    * **Outliers:** Extreme values (outliers) in your data can significantly impact the regression results.
                    """)

                except Exception as e:
                    st.error(f"An error occurred during regression analysis. Please check your data and column names. Error: {e}")

    except Exception as e:
        st.error(f"Error reading the file. Please ensure it's a valid CSV or Excel format and try again. Error: {e}")
else:
    st.info("Please upload a CSV or Excel file to begin the analysis.")

